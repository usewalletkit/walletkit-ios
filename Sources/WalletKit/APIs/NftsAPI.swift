//
// NftsAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

open class NftsAPI {

    /**
     Create NFT Collection
     
     - parameter nftsCreateRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the result
     */
    @discardableResult
    open class func nftsCreate(nftsCreateRequest: NftsCreateRequest, apiResponseQueue: DispatchQueue = WalletKitAPI.apiResponseQueue, completion: @escaping ((_ result: Swift.Result<TransactionSubmissionResponse, ErrorResponse>) -> Void)) -> RequestTask {
        return nftsCreateWithRequestBuilder(nftsCreateRequest: nftsCreateRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(.success(response.body))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Create NFT Collection
     - POST /nfts/collections
     - Creates an NFT Collection with provided metadata. An NFT collection refers to a group of non-fungible tokens (NFTs) that are created and released together, often following a specific theme or concept. NFTs are unique digital assets that are stored on a blockchain, represent ownership or proof of authenticity of a particular item, artwork, or digital content. The created nft collection's address can be found by `/transactions/status-by-id` endpoint once the transaction is succeeded. 
     - Bearer Token:
       - type: http
       - name: BearerAuth
     - parameter nftsCreateRequest: (body)  
     - returns: RequestBuilder<TransactionSubmissionResponse> 
     */
    open class func nftsCreateWithRequestBuilder(nftsCreateRequest: NftsCreateRequest) -> RequestBuilder<TransactionSubmissionResponse> {
        let localVariablePath = "/nfts/collections"
        let localVariableURLString = WalletKitAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: nftsCreateRequest)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<TransactionSubmissionResponse>.Type = WalletKitAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get NFT Collection
     
     - parameter network: (query)  (optional)
     - parameter collectionAddress: (query) address of the NFT contract (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the result
     */
    @discardableResult
    open class func nftsGetNftCollection(network: Network? = nil, collectionAddress: String? = nil, apiResponseQueue: DispatchQueue = WalletKitAPI.apiResponseQueue, completion: @escaping ((_ result: Swift.Result<NftCollection, ErrorResponse>) -> Void)) -> RequestTask {
        return nftsGetNftCollectionWithRequestBuilder(network: network, collectionAddress: collectionAddress).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(.success(response.body))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Get NFT Collection
     - GET /nfts/collection-by-address
     - Get NFT collection by collection address
     - Bearer Token:
       - type: http
       - name: BearerAuth
     - parameter network: (query)  (optional)
     - parameter collectionAddress: (query) address of the NFT contract (optional)
     - returns: RequestBuilder<NftCollection> 
     */
    open class func nftsGetNftCollectionWithRequestBuilder(network: Network? = nil, collectionAddress: String? = nil) -> RequestBuilder<NftCollection> {
        let localVariablePath = "/nfts/collection-by-address"
        let localVariableURLString = WalletKitAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "network": (wrappedValue: network?.encodeToJSON(), isExplode: true),
            "collection_address": (wrappedValue: collectionAddress?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<NftCollection>.Type = WalletKitAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     List NFT Collections
     
     - parameter network: (query)  
     - parameter walletAddress: (query)  
     - parameter page: (query) page number starting from 1 (optional)
     - parameter pageSize: (query) size of each page (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the result
     */
    @discardableResult
    open class func nftsListNftCollections(network: Network, walletAddress: String, page: Int? = nil, pageSize: Int? = nil, apiResponseQueue: DispatchQueue = WalletKitAPI.apiResponseQueue, completion: @escaping ((_ result: Swift.Result<[NftCollection], ErrorResponse>) -> Void)) -> RequestTask {
        return nftsListNftCollectionsWithRequestBuilder(network: network, walletAddress: walletAddress, page: page, pageSize: pageSize).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(.success(response.body))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     List NFT Collections
     - GET /nfts/collections
     - List NFT collections owned by wallet
     - Bearer Token:
       - type: http
       - name: BearerAuth
     - parameter network: (query)  
     - parameter walletAddress: (query)  
     - parameter page: (query) page number starting from 1 (optional)
     - parameter pageSize: (query) size of each page (optional)
     - returns: RequestBuilder<[NftCollection]> 
     */
    open class func nftsListNftCollectionsWithRequestBuilder(network: Network, walletAddress: String, page: Int? = nil, pageSize: Int? = nil) -> RequestBuilder<[NftCollection]> {
        let localVariablePath = "/nfts/collections"
        let localVariableURLString = WalletKitAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "network": (wrappedValue: network.encodeToJSON(), isExplode: true),
            "wallet_address": (wrappedValue: walletAddress.encodeToJSON(), isExplode: true),
            "page": (wrappedValue: page?.encodeToJSON(), isExplode: true),
            "page_size": (wrappedValue: pageSize?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[NftCollection]>.Type = WalletKitAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     List NFTs
     
     - parameter network: (query)  
     - parameter walletAddress: (query) query by wallet address. If provided, contract_address should not be set. (optional)
     - parameter contractAddress: (query) query by collection address. If provided, wallet_address should not be set. (optional)
     - parameter page: (query) page number, starting from 1 (optional)
     - parameter pageSize: (query) size of each page (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the result
     */
    @discardableResult
    open class func nftsListNfts(network: Network, walletAddress: String? = nil, contractAddress: String? = nil, page: Int? = nil, pageSize: Int? = nil, apiResponseQueue: DispatchQueue = WalletKitAPI.apiResponseQueue, completion: @escaping ((_ result: Swift.Result<[Nft], ErrorResponse>) -> Void)) -> RequestTask {
        return nftsListNftsWithRequestBuilder(network: network, walletAddress: walletAddress, contractAddress: contractAddress, page: page, pageSize: pageSize).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(.success(response.body))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     List NFTs
     - GET /nfts
     - List NFTs by wallet or by collection address
     - Bearer Token:
       - type: http
       - name: BearerAuth
     - parameter network: (query)  
     - parameter walletAddress: (query) query by wallet address. If provided, contract_address should not be set. (optional)
     - parameter contractAddress: (query) query by collection address. If provided, wallet_address should not be set. (optional)
     - parameter page: (query) page number, starting from 1 (optional)
     - parameter pageSize: (query) size of each page (optional)
     - returns: RequestBuilder<[Nft]> 
     */
    open class func nftsListNftsWithRequestBuilder(network: Network, walletAddress: String? = nil, contractAddress: String? = nil, page: Int? = nil, pageSize: Int? = nil) -> RequestBuilder<[Nft]> {
        let localVariablePath = "/nfts"
        let localVariableURLString = WalletKitAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "network": (wrappedValue: network.encodeToJSON(), isExplode: true),
            "wallet_address": (wrappedValue: walletAddress?.encodeToJSON(), isExplode: true),
            "contract_address": (wrappedValue: contractAddress?.encodeToJSON(), isExplode: true),
            "page": (wrappedValue: page?.encodeToJSON(), isExplode: true),
            "page_size": (wrappedValue: pageSize?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[Nft]>.Type = WalletKitAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Mint NFT
     
     - parameter nftsMintNftRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the result
     */
    @discardableResult
    open class func nftsMintNft(nftsMintNftRequest: NftsMintNftRequest, apiResponseQueue: DispatchQueue = WalletKitAPI.apiResponseQueue, completion: @escaping ((_ result: Swift.Result<TransactionSubmissionResponse, ErrorResponse>) -> Void)) -> RequestTask {
        return nftsMintNftWithRequestBuilder(nftsMintNftRequest: nftsMintNftRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(.success(response.body))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Mint NFT
     - POST /nfts/mint
     - Mints a NFT from a collection
     - Bearer Token:
       - type: http
       - name: BearerAuth
     - parameter nftsMintNftRequest: (body)  
     - returns: RequestBuilder<TransactionSubmissionResponse> 
     */
    open class func nftsMintNftWithRequestBuilder(nftsMintNftRequest: NftsMintNftRequest) -> RequestBuilder<TransactionSubmissionResponse> {
        let localVariablePath = "/nfts/mint"
        let localVariableURLString = WalletKitAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: nftsMintNftRequest)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<TransactionSubmissionResponse>.Type = WalletKitAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Upload NFT image
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the result
     */
    @discardableResult
    open class func nftsNftImageUpload(apiResponseQueue: DispatchQueue = WalletKitAPI.apiResponseQueue, completion: @escaping ((_ result: Swift.Result<NftImageUploadResponse, ErrorResponse>) -> Void)) -> RequestTask {
        return nftsNftImageUploadWithRequestBuilder().execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(.success(response.body))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Upload NFT image
     - POST /nfts/upload
     - Upload NFT image to IPFS
     - Bearer Token:
       - type: http
       - name: BearerAuth
     - returns: RequestBuilder<NftImageUploadResponse> 
     */
    open class func nftsNftImageUploadWithRequestBuilder() -> RequestBuilder<NftImageUploadResponse> {
        let localVariablePath = "/nfts/upload"
        let localVariableURLString = WalletKitAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<NftImageUploadResponse>.Type = WalletKitAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Transfer NFT
     
     - parameter nftsTransferNftRequest: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the result
     */
    @discardableResult
    open class func nftsTransferNft(nftsTransferNftRequest: NftsTransferNftRequest, apiResponseQueue: DispatchQueue = WalletKitAPI.apiResponseQueue, completion: @escaping ((_ result: Swift.Result<TransactionSubmissionResponse, ErrorResponse>) -> Void)) -> RequestTask {
        return nftsTransferNftWithRequestBuilder(nftsTransferNftRequest: nftsTransferNftRequest).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(.success(response.body))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Transfer NFT
     - POST /nfts/transfer
     - Transfers NFT from `from` to `recipient`. The from address must be wallet created in the project.
     - Bearer Token:
       - type: http
       - name: BearerAuth
     - parameter nftsTransferNftRequest: (body)  
     - returns: RequestBuilder<TransactionSubmissionResponse> 
     */
    open class func nftsTransferNftWithRequestBuilder(nftsTransferNftRequest: NftsTransferNftRequest) -> RequestBuilder<TransactionSubmissionResponse> {
        let localVariablePath = "/nfts/transfer"
        let localVariableURLString = WalletKitAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: nftsTransferNftRequest)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<TransactionSubmissionResponse>.Type = WalletKitAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }
}
